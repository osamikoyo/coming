// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v3.21.12
// source: main.proto

package proto

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	HomeWorkMaking_Create_FullMethodName         = "/HomeWorkMaking/Create"
	HomeWorkMaking_GetHomeWork_FullMethodName    = "/HomeWorkMaking/GetHomeWork"
	HomeWorkMaking_UpdateHomeWork_FullMethodName = "/HomeWorkMaking/UpdateHomeWork"
)

// HomeWorkMakingClient is the client API for HomeWorkMaking service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type HomeWorkMakingClient interface {
	Create(ctx context.Context, in *ReqHomework, opts ...grpc.CallOption) (*Response, error)
	GetHomeWork(ctx context.Context, in *HelpHomeWork, opts ...grpc.CallOption) (*RespHomeWorks, error)
	UpdateHomeWork(ctx context.Context, in *ReqHelp, opts ...grpc.CallOption) (*Response, error)
}

type homeWorkMakingClient struct {
	cc grpc.ClientConnInterface
}

func NewHomeWorkMakingClient(cc grpc.ClientConnInterface) HomeWorkMakingClient {
	return &homeWorkMakingClient{cc}
}

func (c *homeWorkMakingClient) Create(ctx context.Context, in *ReqHomework, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, HomeWorkMaking_Create_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *homeWorkMakingClient) GetHomeWork(ctx context.Context, in *HelpHomeWork, opts ...grpc.CallOption) (*RespHomeWorks, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RespHomeWorks)
	err := c.cc.Invoke(ctx, HomeWorkMaking_GetHomeWork_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *homeWorkMakingClient) UpdateHomeWork(ctx context.Context, in *ReqHelp, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, HomeWorkMaking_UpdateHomeWork_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// HomeWorkMakingServer is the server API for HomeWorkMaking service.
// All implementations must embed UnimplementedHomeWorkMakingServer
// for forward compatibility.
type HomeWorkMakingServer interface {
	Create(context.Context, *ReqHomework) (*Response, error)
	GetHomeWork(context.Context, *HelpHomeWork) (*RespHomeWorks, error)
	UpdateHomeWork(context.Context, *ReqHelp) (*Response, error)
	mustEmbedUnimplementedHomeWorkMakingServer()
}

// UnimplementedHomeWorkMakingServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedHomeWorkMakingServer struct{}

func (UnimplementedHomeWorkMakingServer) Create(context.Context, *ReqHomework) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Create not implemented")
}
func (UnimplementedHomeWorkMakingServer) GetHomeWork(context.Context, *HelpHomeWork) (*RespHomeWorks, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetHomeWork not implemented")
}
func (UnimplementedHomeWorkMakingServer) UpdateHomeWork(context.Context, *ReqHelp) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateHomeWork not implemented")
}
func (UnimplementedHomeWorkMakingServer) mustEmbedUnimplementedHomeWorkMakingServer() {}
func (UnimplementedHomeWorkMakingServer) testEmbeddedByValue()                        {}

// UnsafeHomeWorkMakingServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to HomeWorkMakingServer will
// result in compilation errors.
type UnsafeHomeWorkMakingServer interface {
	mustEmbedUnimplementedHomeWorkMakingServer()
}

func RegisterHomeWorkMakingServer(s grpc.ServiceRegistrar, srv HomeWorkMakingServer) {
	// If the following call pancis, it indicates UnimplementedHomeWorkMakingServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&HomeWorkMaking_ServiceDesc, srv)
}

func _HomeWorkMaking_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReqHomework)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HomeWorkMakingServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HomeWorkMaking_Create_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HomeWorkMakingServer).Create(ctx, req.(*ReqHomework))
	}
	return interceptor(ctx, in, info, handler)
}

func _HomeWorkMaking_GetHomeWork_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HelpHomeWork)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HomeWorkMakingServer).GetHomeWork(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HomeWorkMaking_GetHomeWork_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HomeWorkMakingServer).GetHomeWork(ctx, req.(*HelpHomeWork))
	}
	return interceptor(ctx, in, info, handler)
}

func _HomeWorkMaking_UpdateHomeWork_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReqHelp)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HomeWorkMakingServer).UpdateHomeWork(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HomeWorkMaking_UpdateHomeWork_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HomeWorkMakingServer).UpdateHomeWork(ctx, req.(*ReqHelp))
	}
	return interceptor(ctx, in, info, handler)
}

// HomeWorkMaking_ServiceDesc is the grpc.ServiceDesc for HomeWorkMaking service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var HomeWorkMaking_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "HomeWorkMaking",
	HandlerType: (*HomeWorkMakingServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Create",
			Handler:    _HomeWorkMaking_Create_Handler,
		},
		{
			MethodName: "GetHomeWork",
			Handler:    _HomeWorkMaking_GetHomeWork_Handler,
		},
		{
			MethodName: "UpdateHomeWork",
			Handler:    _HomeWorkMaking_UpdateHomeWork_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "main.proto",
}

const (
	CommingMaking_Create_FullMethodName = "/CommingMaking/Create"
	CommingMaking_Get_FullMethodName    = "/CommingMaking/Get"
	CommingMaking_Remove_FullMethodName = "/CommingMaking/Remove"
)

// CommingMakingClient is the client API for CommingMaking service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CommingMakingClient interface {
	Create(ctx context.Context, in *ReqComming, opts ...grpc.CallOption) (*Response, error)
	Get(ctx context.Context, in *UserReq, opts ...grpc.CallOption) (*RespComming, error)
	Remove(ctx context.Context, in *ReqComming, opts ...grpc.CallOption) (*Response, error)
}

type commingMakingClient struct {
	cc grpc.ClientConnInterface
}

func NewCommingMakingClient(cc grpc.ClientConnInterface) CommingMakingClient {
	return &commingMakingClient{cc}
}

func (c *commingMakingClient) Create(ctx context.Context, in *ReqComming, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, CommingMaking_Create_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *commingMakingClient) Get(ctx context.Context, in *UserReq, opts ...grpc.CallOption) (*RespComming, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RespComming)
	err := c.cc.Invoke(ctx, CommingMaking_Get_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *commingMakingClient) Remove(ctx context.Context, in *ReqComming, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, CommingMaking_Remove_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CommingMakingServer is the server API for CommingMaking service.
// All implementations must embed UnimplementedCommingMakingServer
// for forward compatibility.
type CommingMakingServer interface {
	Create(context.Context, *ReqComming) (*Response, error)
	Get(context.Context, *UserReq) (*RespComming, error)
	Remove(context.Context, *ReqComming) (*Response, error)
	mustEmbedUnimplementedCommingMakingServer()
}

// UnimplementedCommingMakingServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedCommingMakingServer struct{}

func (UnimplementedCommingMakingServer) Create(context.Context, *ReqComming) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Create not implemented")
}
func (UnimplementedCommingMakingServer) Get(context.Context, *UserReq) (*RespComming, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedCommingMakingServer) Remove(context.Context, *ReqComming) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Remove not implemented")
}
func (UnimplementedCommingMakingServer) mustEmbedUnimplementedCommingMakingServer() {}
func (UnimplementedCommingMakingServer) testEmbeddedByValue()                       {}

// UnsafeCommingMakingServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CommingMakingServer will
// result in compilation errors.
type UnsafeCommingMakingServer interface {
	mustEmbedUnimplementedCommingMakingServer()
}

func RegisterCommingMakingServer(s grpc.ServiceRegistrar, srv CommingMakingServer) {
	// If the following call pancis, it indicates UnimplementedCommingMakingServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&CommingMaking_ServiceDesc, srv)
}

func _CommingMaking_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReqComming)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommingMakingServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CommingMaking_Create_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommingMakingServer).Create(ctx, req.(*ReqComming))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommingMaking_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommingMakingServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CommingMaking_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommingMakingServer).Get(ctx, req.(*UserReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommingMaking_Remove_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReqComming)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommingMakingServer).Remove(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CommingMaking_Remove_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommingMakingServer).Remove(ctx, req.(*ReqComming))
	}
	return interceptor(ctx, in, info, handler)
}

// CommingMaking_ServiceDesc is the grpc.ServiceDesc for CommingMaking service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CommingMaking_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "CommingMaking",
	HandlerType: (*CommingMakingServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Create",
			Handler:    _CommingMaking_Create_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _CommingMaking_Get_Handler,
		},
		{
			MethodName: "Remove",
			Handler:    _CommingMaking_Remove_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "main.proto",
}

const (
	LessonsMaking_Create_FullMethodName = "/LessonsMaking/Create"
	LessonsMaking_Get_FullMethodName    = "/LessonsMaking/Get"
	LessonsMaking_Update_FullMethodName = "/LessonsMaking/Update"
	LessonsMaking_Delete_FullMethodName = "/LessonsMaking/Delete"
)

// LessonsMakingClient is the client API for LessonsMaking service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type LessonsMakingClient interface {
	Create(ctx context.Context, in *ReqLesson, opts ...grpc.CallOption) (*Response, error)
	Get(ctx context.Context, in *HelpGetLessons, opts ...grpc.CallOption) (*RespLesson, error)
	Update(ctx context.Context, in *HelpGetLessons, opts ...grpc.CallOption) (*Response, error)
	Delete(ctx context.Context, in *ReqLesson, opts ...grpc.CallOption) (*Response, error)
}

type lessonsMakingClient struct {
	cc grpc.ClientConnInterface
}

func NewLessonsMakingClient(cc grpc.ClientConnInterface) LessonsMakingClient {
	return &lessonsMakingClient{cc}
}

func (c *lessonsMakingClient) Create(ctx context.Context, in *ReqLesson, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, LessonsMaking_Create_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lessonsMakingClient) Get(ctx context.Context, in *HelpGetLessons, opts ...grpc.CallOption) (*RespLesson, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RespLesson)
	err := c.cc.Invoke(ctx, LessonsMaking_Get_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lessonsMakingClient) Update(ctx context.Context, in *HelpGetLessons, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, LessonsMaking_Update_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lessonsMakingClient) Delete(ctx context.Context, in *ReqLesson, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, LessonsMaking_Delete_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// LessonsMakingServer is the server API for LessonsMaking service.
// All implementations must embed UnimplementedLessonsMakingServer
// for forward compatibility.
type LessonsMakingServer interface {
	Create(context.Context, *ReqLesson) (*Response, error)
	Get(context.Context, *HelpGetLessons) (*RespLesson, error)
	Update(context.Context, *HelpGetLessons) (*Response, error)
	Delete(context.Context, *ReqLesson) (*Response, error)
	mustEmbedUnimplementedLessonsMakingServer()
}

// UnimplementedLessonsMakingServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedLessonsMakingServer struct{}

func (UnimplementedLessonsMakingServer) Create(context.Context, *ReqLesson) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Create not implemented")
}
func (UnimplementedLessonsMakingServer) Get(context.Context, *HelpGetLessons) (*RespLesson, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedLessonsMakingServer) Update(context.Context, *HelpGetLessons) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}
func (UnimplementedLessonsMakingServer) Delete(context.Context, *ReqLesson) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedLessonsMakingServer) mustEmbedUnimplementedLessonsMakingServer() {}
func (UnimplementedLessonsMakingServer) testEmbeddedByValue()                       {}

// UnsafeLessonsMakingServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to LessonsMakingServer will
// result in compilation errors.
type UnsafeLessonsMakingServer interface {
	mustEmbedUnimplementedLessonsMakingServer()
}

func RegisterLessonsMakingServer(s grpc.ServiceRegistrar, srv LessonsMakingServer) {
	// If the following call pancis, it indicates UnimplementedLessonsMakingServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&LessonsMaking_ServiceDesc, srv)
}

func _LessonsMaking_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReqLesson)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LessonsMakingServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LessonsMaking_Create_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LessonsMakingServer).Create(ctx, req.(*ReqLesson))
	}
	return interceptor(ctx, in, info, handler)
}

func _LessonsMaking_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HelpGetLessons)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LessonsMakingServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LessonsMaking_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LessonsMakingServer).Get(ctx, req.(*HelpGetLessons))
	}
	return interceptor(ctx, in, info, handler)
}

func _LessonsMaking_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HelpGetLessons)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LessonsMakingServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LessonsMaking_Update_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LessonsMakingServer).Update(ctx, req.(*HelpGetLessons))
	}
	return interceptor(ctx, in, info, handler)
}

func _LessonsMaking_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReqLesson)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LessonsMakingServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LessonsMaking_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LessonsMakingServer).Delete(ctx, req.(*ReqLesson))
	}
	return interceptor(ctx, in, info, handler)
}

// LessonsMaking_ServiceDesc is the grpc.ServiceDesc for LessonsMaking service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var LessonsMaking_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "LessonsMaking",
	HandlerType: (*LessonsMakingServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Create",
			Handler:    _LessonsMaking_Create_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _LessonsMaking_Get_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _LessonsMaking_Update_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _LessonsMaking_Delete_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "main.proto",
}

const (
	UserMaking_Register_FullMethodName = "/UserMaking/Register"
	UserMaking_Login_FullMethodName    = "/UserMaking/Login"
	UserMaking_Auth_FullMethodName     = "/UserMaking/Auth"
)

// UserMakingClient is the client API for UserMaking service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type UserMakingClient interface {
	Register(ctx context.Context, in *UserReq, opts ...grpc.CallOption) (*Response, error)
	Login(ctx context.Context, in *UserReq, opts ...grpc.CallOption) (*Response, error)
	Auth(ctx context.Context, in *UserReq, opts ...grpc.CallOption) (*TKN, error)
}

type userMakingClient struct {
	cc grpc.ClientConnInterface
}

func NewUserMakingClient(cc grpc.ClientConnInterface) UserMakingClient {
	return &userMakingClient{cc}
}

func (c *userMakingClient) Register(ctx context.Context, in *UserReq, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, UserMaking_Register_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userMakingClient) Login(ctx context.Context, in *UserReq, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, UserMaking_Login_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userMakingClient) Auth(ctx context.Context, in *UserReq, opts ...grpc.CallOption) (*TKN, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TKN)
	err := c.cc.Invoke(ctx, UserMaking_Auth_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UserMakingServer is the server API for UserMaking service.
// All implementations must embed UnimplementedUserMakingServer
// for forward compatibility.
type UserMakingServer interface {
	Register(context.Context, *UserReq) (*Response, error)
	Login(context.Context, *UserReq) (*Response, error)
	Auth(context.Context, *UserReq) (*TKN, error)
	mustEmbedUnimplementedUserMakingServer()
}

// UnimplementedUserMakingServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedUserMakingServer struct{}

func (UnimplementedUserMakingServer) Register(context.Context, *UserReq) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Register not implemented")
}
func (UnimplementedUserMakingServer) Login(context.Context, *UserReq) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Login not implemented")
}
func (UnimplementedUserMakingServer) Auth(context.Context, *UserReq) (*TKN, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Auth not implemented")
}
func (UnimplementedUserMakingServer) mustEmbedUnimplementedUserMakingServer() {}
func (UnimplementedUserMakingServer) testEmbeddedByValue()                    {}

// UnsafeUserMakingServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UserMakingServer will
// result in compilation errors.
type UnsafeUserMakingServer interface {
	mustEmbedUnimplementedUserMakingServer()
}

func RegisterUserMakingServer(s grpc.ServiceRegistrar, srv UserMakingServer) {
	// If the following call pancis, it indicates UnimplementedUserMakingServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&UserMaking_ServiceDesc, srv)
}

func _UserMaking_Register_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserMakingServer).Register(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserMaking_Register_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserMakingServer).Register(ctx, req.(*UserReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserMaking_Login_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserMakingServer).Login(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserMaking_Login_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserMakingServer).Login(ctx, req.(*UserReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserMaking_Auth_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserMakingServer).Auth(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserMaking_Auth_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserMakingServer).Auth(ctx, req.(*UserReq))
	}
	return interceptor(ctx, in, info, handler)
}

// UserMaking_ServiceDesc is the grpc.ServiceDesc for UserMaking service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var UserMaking_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "UserMaking",
	HandlerType: (*UserMakingServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Register",
			Handler:    _UserMaking_Register_Handler,
		},
		{
			MethodName: "Login",
			Handler:    _UserMaking_Login_Handler,
		},
		{
			MethodName: "Auth",
			Handler:    _UserMaking_Auth_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "main.proto",
}

const (
	MarksMaking_Create_FullMethodName = "/MarksMaking/Create"
	MarksMaking_Delete_FullMethodName = "/MarksMaking/Delete"
	MarksMaking_Get_FullMethodName    = "/MarksMaking/Get"
)

// MarksMakingClient is the client API for MarksMaking service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type MarksMakingClient interface {
	Create(ctx context.Context, in *ReqMark, opts ...grpc.CallOption) (*Response, error)
	Delete(ctx context.Context, in *ReqHelpMark, opts ...grpc.CallOption) (*Response, error)
	Get(ctx context.Context, in *ReqHelpMark, opts ...grpc.CallOption) (*RespHelpMark, error)
}

type marksMakingClient struct {
	cc grpc.ClientConnInterface
}

func NewMarksMakingClient(cc grpc.ClientConnInterface) MarksMakingClient {
	return &marksMakingClient{cc}
}

func (c *marksMakingClient) Create(ctx context.Context, in *ReqMark, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, MarksMaking_Create_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *marksMakingClient) Delete(ctx context.Context, in *ReqHelpMark, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, MarksMaking_Delete_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *marksMakingClient) Get(ctx context.Context, in *ReqHelpMark, opts ...grpc.CallOption) (*RespHelpMark, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RespHelpMark)
	err := c.cc.Invoke(ctx, MarksMaking_Get_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MarksMakingServer is the server API for MarksMaking service.
// All implementations must embed UnimplementedMarksMakingServer
// for forward compatibility.
type MarksMakingServer interface {
	Create(context.Context, *ReqMark) (*Response, error)
	Delete(context.Context, *ReqHelpMark) (*Response, error)
	Get(context.Context, *ReqHelpMark) (*RespHelpMark, error)
	mustEmbedUnimplementedMarksMakingServer()
}

// UnimplementedMarksMakingServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedMarksMakingServer struct{}

func (UnimplementedMarksMakingServer) Create(context.Context, *ReqMark) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Create not implemented")
}
func (UnimplementedMarksMakingServer) Delete(context.Context, *ReqHelpMark) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedMarksMakingServer) Get(context.Context, *ReqHelpMark) (*RespHelpMark, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedMarksMakingServer) mustEmbedUnimplementedMarksMakingServer() {}
func (UnimplementedMarksMakingServer) testEmbeddedByValue()                     {}

// UnsafeMarksMakingServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MarksMakingServer will
// result in compilation errors.
type UnsafeMarksMakingServer interface {
	mustEmbedUnimplementedMarksMakingServer()
}

func RegisterMarksMakingServer(s grpc.ServiceRegistrar, srv MarksMakingServer) {
	// If the following call pancis, it indicates UnimplementedMarksMakingServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&MarksMaking_ServiceDesc, srv)
}

func _MarksMaking_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReqMark)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MarksMakingServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MarksMaking_Create_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MarksMakingServer).Create(ctx, req.(*ReqMark))
	}
	return interceptor(ctx, in, info, handler)
}

func _MarksMaking_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReqHelpMark)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MarksMakingServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MarksMaking_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MarksMakingServer).Delete(ctx, req.(*ReqHelpMark))
	}
	return interceptor(ctx, in, info, handler)
}

func _MarksMaking_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReqHelpMark)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MarksMakingServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MarksMaking_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MarksMakingServer).Get(ctx, req.(*ReqHelpMark))
	}
	return interceptor(ctx, in, info, handler)
}

// MarksMaking_ServiceDesc is the grpc.ServiceDesc for MarksMaking service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var MarksMaking_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "MarksMaking",
	HandlerType: (*MarksMakingServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Create",
			Handler:    _MarksMaking_Create_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _MarksMaking_Delete_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _MarksMaking_Get_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "main.proto",
}

const (
	TeacherMaking_Create_FullMethodName = "/TeacherMaking/Create"
	TeacherMaking_Login_FullMethodName  = "/TeacherMaking/Login"
	TeacherMaking_Auth_FullMethodName   = "/TeacherMaking/Auth"
)

// TeacherMakingClient is the client API for TeacherMaking service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TeacherMakingClient interface {
	Create(ctx context.Context, in *ReqTeacher, opts ...grpc.CallOption) (*Response, error)
	Login(ctx context.Context, in *ReqTeacher, opts ...grpc.CallOption) (*RespTeacher, error)
	Auth(ctx context.Context, in *ReqTeacher, opts ...grpc.CallOption) (*TKN, error)
}

type teacherMakingClient struct {
	cc grpc.ClientConnInterface
}

func NewTeacherMakingClient(cc grpc.ClientConnInterface) TeacherMakingClient {
	return &teacherMakingClient{cc}
}

func (c *teacherMakingClient) Create(ctx context.Context, in *ReqTeacher, opts ...grpc.CallOption) (*Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Response)
	err := c.cc.Invoke(ctx, TeacherMaking_Create_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *teacherMakingClient) Login(ctx context.Context, in *ReqTeacher, opts ...grpc.CallOption) (*RespTeacher, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RespTeacher)
	err := c.cc.Invoke(ctx, TeacherMaking_Login_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *teacherMakingClient) Auth(ctx context.Context, in *ReqTeacher, opts ...grpc.CallOption) (*TKN, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TKN)
	err := c.cc.Invoke(ctx, TeacherMaking_Auth_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TeacherMakingServer is the server API for TeacherMaking service.
// All implementations must embed UnimplementedTeacherMakingServer
// for forward compatibility.
type TeacherMakingServer interface {
	Create(context.Context, *ReqTeacher) (*Response, error)
	Login(context.Context, *ReqTeacher) (*RespTeacher, error)
	Auth(context.Context, *ReqTeacher) (*TKN, error)
	mustEmbedUnimplementedTeacherMakingServer()
}

// UnimplementedTeacherMakingServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedTeacherMakingServer struct{}

func (UnimplementedTeacherMakingServer) Create(context.Context, *ReqTeacher) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Create not implemented")
}
func (UnimplementedTeacherMakingServer) Login(context.Context, *ReqTeacher) (*RespTeacher, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Login not implemented")
}
func (UnimplementedTeacherMakingServer) Auth(context.Context, *ReqTeacher) (*TKN, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Auth not implemented")
}
func (UnimplementedTeacherMakingServer) mustEmbedUnimplementedTeacherMakingServer() {}
func (UnimplementedTeacherMakingServer) testEmbeddedByValue()                       {}

// UnsafeTeacherMakingServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TeacherMakingServer will
// result in compilation errors.
type UnsafeTeacherMakingServer interface {
	mustEmbedUnimplementedTeacherMakingServer()
}

func RegisterTeacherMakingServer(s grpc.ServiceRegistrar, srv TeacherMakingServer) {
	// If the following call pancis, it indicates UnimplementedTeacherMakingServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&TeacherMaking_ServiceDesc, srv)
}

func _TeacherMaking_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReqTeacher)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TeacherMakingServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TeacherMaking_Create_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TeacherMakingServer).Create(ctx, req.(*ReqTeacher))
	}
	return interceptor(ctx, in, info, handler)
}

func _TeacherMaking_Login_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReqTeacher)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TeacherMakingServer).Login(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TeacherMaking_Login_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TeacherMakingServer).Login(ctx, req.(*ReqTeacher))
	}
	return interceptor(ctx, in, info, handler)
}

func _TeacherMaking_Auth_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReqTeacher)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TeacherMakingServer).Auth(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TeacherMaking_Auth_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TeacherMakingServer).Auth(ctx, req.(*ReqTeacher))
	}
	return interceptor(ctx, in, info, handler)
}

// TeacherMaking_ServiceDesc is the grpc.ServiceDesc for TeacherMaking service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var TeacherMaking_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "TeacherMaking",
	HandlerType: (*TeacherMakingServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Create",
			Handler:    _TeacherMaking_Create_Handler,
		},
		{
			MethodName: "Login",
			Handler:    _TeacherMaking_Login_Handler,
		},
		{
			MethodName: "Auth",
			Handler:    _TeacherMaking_Auth_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "main.proto",
}
